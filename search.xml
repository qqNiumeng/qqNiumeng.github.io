<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue基础笔记</title>
      <link href="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue兼容html规则"><a href="#Vue兼容html规则" class="headerlink" title="Vue兼容html规则"></a>Vue兼容html规则</h3><p>&lt;组件名称   区域2（组件属性赋值）&gt;   区域1 &lt;&#x2F;组件名称&gt;</p><p>区域1：可输入直接展示的字串或嵌套其他组件</p><p>​Vue规则为{ {  表达式  } } </p><p>区域2：key&#x3D;”value”赋值组件属性</p><p>​value有时要求为表达式，有时则只是普通字符串</p><p>​Vue规则为   当value要求为普通对象时，且想通过表达式传递值时，可以加上v-bind：前缀,Vue解析模板时视为表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">    &lt;h1 v-bind:value=&quot;name&quot;&gt;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">    &lt;!-- 简写1 ：value=&quot;name&quot;--&gt;</span><br><span class="line">&lt;!-- 简写2: v-bind=&quot;name&quot; 默认赋给value属性--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&#x27;#root&#x27;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            name:&#x27;jack&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="数据绑定与代理"><a href="#数据绑定与代理" class="headerlink" title="数据绑定与代理"></a>数据绑定与代理</h3><h5 id="数据绑定："><a href="#数据绑定：" class="headerlink" title="数据绑定："></a>数据绑定：</h5><p>​使用 v-bind时，Vue单向检测到引用的data下的变量变化（如上例中name）时，会及时重新解析容器，重新渲染展示最新的变量值</p><p>​使用v-model时，Vue双向检测页面输入的值、data下引用的变量，使二者数值保持一致。</p><h5 id="数据绑定的原理："><a href="#数据绑定的原理：" class="headerlink" title="数据绑定的原理："></a>数据绑定的原理：</h5><p>​1.表达式可以直接访问data内变量，因为Vue代理了data对象中的字段</p><p>​2.前端页面值变——&gt;$data变量随着变</p><p>​  $data变量变——&gt;前端页面值变</p><p>​类似解析的过程和解析的反过程</p><h5 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">题外话：js给对象增加属性key</span><br><span class="line">对象名.新属性名 = 属性值</span><br><span class="line">如  Vue._proto_.aa= &#x27;gaga&#x27;;</span><br><span class="line">js删除对象属性</span><br><span class="line">delete Vue._proto_.aa;</span><br></pre></td></tr></table></figure><p>此外，还有一个api可以新增对象字段，并指定新增字段所代理的 变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor);</span><br><span class="line"><span class="comment">//obj:对象</span></span><br><span class="line"><span class="comment">//prop：新增的字段名</span></span><br><span class="line"><span class="comment">/*descriptor：配置对象&#123;</span></span><br><span class="line"><span class="comment">众多属性中有一个getter和setter</span></span><br><span class="line"><span class="comment">get：function()&#123;</span></span><br><span class="line"><span class="comment">return  被代理的对象值</span></span><br><span class="line"><span class="comment">&#125;,</span></span><br><span class="line"><span class="comment">set:function(value)&#123;</span></span><br><span class="line"><span class="comment">    被代理的对象 = value;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>get方法在prop被读取之前调用，返回值即prop被读取到的值；</p><p>set方法在prop被赋值时调用，赋值给 被代理的对象。</p><p>prop没有实际的存储内容，它代理了某个字段，感觉就是把该字段封装到了自己的逻辑内，也像引用。</p><p>可以暴露被代理的字段，但注意不能随便删除。</p><h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><p>？？？</p><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>标签或组件的响应行为</p><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>计算属性是现存属性的代理者且getter、setter可以以某种计算关系 return   f (被代理字段)</p><h4 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h4><p>监视data某属性的字面值，字面值变动时会调用handler方法；</p><p>深度监视：当监视data内对象属性内的属性变化时，也会调用handler方法；</p><p>​开启条件：监视属性的 配置对象中 deep:true</p><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><h4 id="列表渲染、过滤、排序"><a href="#列表渲染、过滤、排序" class="headerlink" title="列表渲染、过滤、排序"></a>列表渲染、过滤、排序</h4><h5 id="key原理："><a href="#key原理：" class="headerlink" title="key原理："></a>key原理：</h5><p>vue使用key属性管理虚拟dom的对比算法的比较依据，依据key的对应关系，将新的虚拟DOM信息补充到旧的DOM信息中，装载完成时（真实DOM）key销毁</p><p>【易错点】</p><ul><li>以数组的索引index为key，引起的对比算法出错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;(stu,index) in students&quot; :key=&quot;index&quot;&gt;</span><br><span class="line"> &#123;&#123;stu.name&#125;&#125;-&#123;&#123;stu.age&#125;&#125;</span><br><span class="line">    &lt;input type=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>假设在输入框输入对应信息</p><p>当使用数组api在数组index&#x3D;0的位置插入新数据时，Vue依据对比算法重新渲染页面，此时会出现意想不到的结果</p><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-20220606233226859.png" class="" title="这是一张图片">![image-20220606233226859](E:\blog\source\_posts\Vue基础笔记\image-20220606233226859.png)<p>因为</p><ul><li>数组下标index  插入前后对应数据是变化的，key也随之变化</li></ul><p>​0张三1李四2王五————0老刘1张三2李四3王五</p><ul><li>而右侧输入框key值始终没有变动</li></ul><p>​所以出现匹配上的差错</p><p>即用数组下标index做为key是不准确的，需要一个不因数组插入顺序而引起变动的恒定的关系值来作为key值，比如主键</p><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>？？  P45</p><h4 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL初印象</title>
      <link href="/2022/06/05/MySQL%E5%88%9D%E5%8D%B0%E8%B1%A1/"/>
      <url>/2022/06/05/MySQL%E5%88%9D%E5%8D%B0%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>查有联表和组合，</p><p>函数不过字段集合。</p><p>过滤得分行分组，</p><p>行过滤全文本还是正则？</p><p>事务擅使细致多，</p><p>游标循环是一伙。</p><p>视图也要挑大梁，</p><p>触发器存储来帮忙。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
