<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring框架IOC基础</title>
      <link href="/2022/06/22/Spring%E6%A1%86%E6%9E%B6IOC%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/06/22/Spring%E6%A1%86%E6%9E%B6IOC%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><p>注入类 有两种方式</p><p>1、配置文件</p><p>1）创建类定义</p><p>2）bean1.xml  bean标签里定义的类代号和类路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version =<span class="string">&quot;1.0&quot;</span> encoding = <span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;...&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;...&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemalLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置User对象创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.全路径名.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3)测试类</p><p>TestSpring5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1 加载Spring配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//2 获取配置创建的对象(参数1：Bean标签的ID 参数2：要转换成的class类型)</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br><span class="line">    </span><br><span class="line">    System.out.println(user);</span><br><span class="line">    user.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、注解</p><h4 id="IOC容器原理"><a href="#IOC容器原理" class="headerlink" title="IOC容器原理"></a>IOC容器原理</h4><p>（1）IOC的概念</p><p>​IOC：控制反转，把对象的创建和对象之间的调用过程，交给Spring进行管理。</p><p>​目的：降低耦合度</p><p>​上面案例就是IOC实现的。</p><p>（2）IOC原理</p><p>​xml解析、工厂模式、反射</p><img src="/2022/06/22/Spring%E6%A1%86%E6%9E%B6IOC%E5%9F%BA%E7%A1%80/IOC%E8%BF%87%E7%A8%8B.png" class="" title="这是一张图片"><p>![IOC过程](C:\Users\Administrator.DESKTOP-O1Q8NN4\Pictures\Camera Roll\IOC过程.png)</p><p>比如，类路径改变，只需要修改xml中的配置路径。？？？只是这个作用？？？还有类名称</p><p><strong>耦合度真正的意义是什么？？——便于开发、维护</strong></p><p>1、IOC思想基于IOC容器完成，IOC容器底层就是对象工厂。</p><p>2、Spring提供IOC容器实现两种方式（两个接口）</p><p>​1》BeanFactory：IOC容器基本实现，是Spring内部使用的接口，不提供开发人员进行使用。</p><p>​*加载配置文件时候不创建对象。如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>​*在获取对象使用时才去创建对象。如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br></pre></td></tr></table></figure><p>​2》ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能。一般由开发人员进行使用。</p><p>​*在加载配置文件时候就会把在配置文件的对象进行创建</p><p>3、ApplicationContext接口有哪些主要实现类：</p><img src="/2022/06/22/Spring%E6%A1%86%E6%9E%B6IOC%E5%9F%BA%E7%A1%80/BeanFactory%E7%9A%84%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" class="" title="这是一张图片"><p>![BeanFactory的主要实现类](C:\Users\Administrator.DESKTOP-O1Q8NN4\Pictures\Camera Roll\BeanFactory的主要实现类.png)</p><h4 id="Bean管理IOC逻辑演进（xml"><a href="#Bean管理IOC逻辑演进（xml" class="headerlink" title="Bean管理IOC逻辑演进（xml)"></a>Bean管理IOC逻辑演进（xml)</h4><p><strong>单纯new对象，调用其方法</strong>： 调用类和被调类耦合度过高：被调类类路径、类名都有限制</p><p><strong>工厂模式</strong>：由于静态工厂的路径分担了被调类类路径的直接耦合。</p><p><strong>IOC容器：</strong>配置文件中标签属性ID的出现+反射，解除了被调用类名的直接耦合。</p><p>​讲课思路：1、生成对象：可以正常注入类，生成类对象</p><p>​2、属性注入：可以实现类的所有功能。所有构造方法、Getter、Setter方法。前提是在类中提前定义这些方法。（本质是通过反射来调用各个方法）。这时可以<strong>给注入类的字段通过配置文件赋初始值</strong>了</p><p>​3、Bean注入：实现给注入类的字段通过配置文件赋初始值。这个<strong>字段可以是一个注入类</strong>。从反射的角度来看是完全合理的。格式也必须是在类中，先定义一个注入类类型字段。本质和2干的一样的事。</p><p>​4、级联赋值：像3，当一个注入类A中有另一个注入类B字段时候。可以在注入类A的配置文件中，额外对注入类B进行初始化配置。</p><p>​5、集合注入-普通类型：数组、List、Map</p><p>​6、集合注入-对象类型：数组、List、Map</p><p>写法规格，参考尚硅谷:<a href="https://www.bilibili.com/video/BV1Vf4y127N5?p=13&spm_id_from=pageDriver">尚硅谷Spring5框架教程（idea版）_哔哩哔哩_bilibili</a></p><hr><p>现在看来，配置文件就是对注入类<strong>初始化</strong>信息的补充完善，对定义无可奈何</p><hr><p><strong>xml配置文件的的引用</strong></p><p>1、在spring配置文件中引入名称空间util</p><p>2、使用util标签完成list集合注入提取</p><p>写法规格，参考尚硅谷:<a href="https://www.bilibili.com/video/BV1Vf4y127N5?p=14&spm_id_from=pageDriver">尚硅谷Spring5框架教程（idea版）_哔哩哔哩_bilibili</a></p><p><strong>FactoryBean</strong></p><p>1、Spring有两种类型的Bean，一种普通Bean，另一种工厂Bean（FactoryBean）</p><p>​普通Bean：在配置文件中定义bean类型就是返回类型；</p><p>​工厂Bean：在配置文件<strong>定义bean类型可以和返回类型可以不一样</strong>。</p><p>2、FactoryBean区别于Bean的操作</p><p>​1)类的定义需要实现FactoryBean接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Student&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//确定返回bean类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getObject</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        stu.setName(<span class="string">&quot;牛猛&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否是单例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​2)配置文件同上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFactoryBean</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//注意下面是你确定返回的类，而配置文件所附的定义类</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;stu&quot;</span>,Student);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p> 1、在Spring里面，<strong>默认</strong>情况下Bean类都是<strong>单实例</strong>对象。</p><p>2、设置单实例、多实例：scope属性:prototype(多实例)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> =<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.excample.student&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、singleton单实例和prototype多实例区别</p><p>​scope&#x3D;”singleton”时，加载Spring配置文件时候就会创建单实例对象；</p><p>​scope&#x3D;”prototype”时，不是在加载Spring配置文件时候创建对象，而在getBean方法时候创建多实例对象。</p><h4 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h4><p><strong>【可是配置文件在什么时候被加载呢？  和类加载一块？？】</strong></p><p>1、通过构造器创建bean实例（无参构造器）</p><p>2、为bean的属性设置值和对其他bean引用（调用set方法）</p><p>3、把Bean实例传递bean后置处理器的postProcessBeforeInitialization 方法（需要配置bean后置处理器）</p><p>4、调用bean的初始化的方法（需要进行配置初始化的方法）</p><p>5、把Bean实例传递bean后置处理器的postProcessAfterInitialization方法 （需要配置bean后置处理器）</p><p>6、bean可以使用了（对象获取到了）</p><p>7、当容器关闭时候，调用bean的销毁方法（需要进行配置销毁的方法）</p><p>  <strong>初始化方法</strong>和<strong>销毁方法</strong>的配置实例</p><p>​1）在类中定义</p><p>​2）在配置文件中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.stu&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;myInitMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;myDestroyMethod&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​3）调用时选择支持销毁的类接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBean</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//ApplicationContext context = new    ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);不支持</span></span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span>    <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;stu&quot;</span>,Student.class);</span><br><span class="line">    ...</span><br><span class="line">    con.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**演示添加后置处理器 **</p><p>​1）创建类MyBeanPost，实现接口BeanPostProcessor，创建后置处理器</p><p>​2）重写两个方法</p><p>​postProcessBeforeInitialization (初始化之前执行的方法)</p><p>​postProcessAfterInitialization （初始化之后执行的方法）</p><p>​3）在Bean配置文件中添加后置处理器配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置后置处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBeanPost&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">Bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>【注意：一个xml配置文件里面，可以有多个Bean标签。】</strong></p><p>所以一个xml可给多个不同诸如类附加配置</p><p>也可以配置后置处理器  </p><p>应该是按照实现的接口来判断是诸如类还是后置处理器（instanceof)</p><p>​该说不说的，如果有两个xml描述一个Bean类会怎么样？？</p><h4 id="Bean管理：xml自动装配-？？？？"><a href="#Bean管理：xml自动装配-？？？？" class="headerlink" title="Bean管理：xml自动装配 ？？？？"></a>Bean管理：xml自动装配 ？？？？</h4><p>1、自动装配：不需要通过在配置文件&lt;Bean&gt;标签内写字段标签来<strong>初始化字段</strong>，而是由Spring自动完成。</p><p>根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入</p><p>2、自动装配过程演示</p><p>​1）定义类字段是bean类型，是其他类型应该没有用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Syudent</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​2）配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--实现自动装配</span></span><br><span class="line"><span class="comment">bean标签属性autowire,配置自动装配</span></span><br><span class="line"><span class="comment">autowire属性常用两个值：</span></span><br><span class="line"><span class="comment">byName:根据属性名称注入，注入到字段的bean的id值和字段名称一样</span></span><br><span class="line"><span class="comment">byType:根据属性类型注入</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Student&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【猜测】运行过程应是，加载配置文件——知道需自动装配的类——遍历自动装配的字段类型，如果IOC容器中有则注入</p><hr><p>【疑问已解决】id或者类型重复存在两个时都会报错。</p><p>像之前Serive只有一个ServiceImpl可能就是这个原因。如果写两个就会报错的。</p><p>我之前好像有一回。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StudentService teacherServioceImpl;</span><br><span class="line"><span class="comment">//结果注入的是TeacherService的实现类去了。</span></span><br></pre></td></tr></table></figure><hr><h4 id="Bean管理：外部属性文件"><a href="#Bean管理：外部属性文件" class="headerlink" title="Bean管理：外部属性文件"></a>Bean管理：外部属性文件</h4><p>比对距离：数据库连接</p><p>1、直接配置数据库信息</p><p>​1)导入druid的jar包</p><p>​2）配置德鲁伊连接池 druid的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、引入外部属性文件配置数据库连接池</p><p>​1)创建外部属性文件，properties格式文件，写数据库信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意先下面实质是键值对，左侧吗，名字随便取，只要在配置文件导入时取得键名一致即可。</span></span><br><span class="line"><span class="comment">#之所以加prop.前缀是为了和其他软件的同字段区分开来</span></span><br><span class="line"><span class="attr">prop.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/userDb</span></span><br><span class="line"><span class="attr">prop.userName</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">prop.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p>​2）把外部properties属性文件引入到spring配置文件中</p><p>​*引入context名称空间 注意&lt;beans&gt;添加了两行context的属性</p><p><strong>【不明白之处：xml怎么导入其他xml空间  和属性文件properties 的】</strong></p><p>​*在Spring配置文件中使用标签引入外部属性文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springfranwork.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     </span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">              http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--引入外部属性文件classpath与src目录一致--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入外部属性文件后，配置文件写法和直接配置数据库一致--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;pro.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>【知识点：${}写法作用？ 】</strong></p><h4 id="Bean管理（注解）"><a href="#Bean管理（注解）" class="headerlink" title="Bean管理（注解）"></a>Bean管理（注解）</h4><p><strong>1、什么是注解？</strong></p><p>​1）注解是代码特殊标记，格式@注解名称（属性名称&#x3D;属性值，属性名称&#x3D;属性值..)；</p><p>​2）注解可以附加在包类方法字段上；</p><p>​3）注解目的：简化xml配置</p><p><strong>2、Spring针对Bean管理中创建对象提供的注解</strong></p><p>​1）@Component</p><p>​2）@Service </p><p>​3）@Controller</p><p>​4）@Repository</p><p>*上面的四个注解功能都是一样的，都可以用来创建Bean实例。一般习惯是：@Controller用在Web层、@Service用在业务逻辑层、@Repositiry用在Dao层，但实际上混用也是可以的。</p><p><strong>3、基于注解方式实现对象创建</strong></p><p>​1）引入依赖</p><p>​spring-aop-5.2.6.RELEASE.jar</p><p>​2）开启组件扫描  在配置文件bean1中开启组件扫描 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springfranwork.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     </span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">              http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描多个同级包时,用逗号隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example.dao,com.example.service&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​3）创建类，在类上面添加创建对象的注解（四个注解任何一个都可以）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解里面的value属性值可以省略不写</span></span><br><span class="line"><span class="comment">//默认值是类名称的首字母小写  UserService——userService</span></span><br><span class="line"><span class="meta">@Component(value = &quot;uerService&quot;)</span>  <span class="comment">//注意这步注解+扫描包== &lt;bean id=&quot;userService&quot; class=&quot;com...&quot;&gt;&lt;bean&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​4）调用类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>,UserService.class);</span><br><span class="line">    sout(userService);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑过程：加载配置文件Bean1——看到有扫描任务——到需要扫描的包，找到@Component等4注解的类，生成Bean实例——context实例调取Bean实例</p><h4 id="Bean扫描优化"><a href="#Bean扫描优化" class="headerlink" title="Bean扫描优化"></a>Bean扫描优化</h4><p>上诉扫描其实调用了系统默认配置的扫描器filter</p><p>程序员可以自己定义并使用心的扫描（比如确定<strong>只扫描</strong>那个包、或者确定<strong>不去扫描</strong>那个包、只扫描@Service注解等…</p><p>配置实例：</p><img src="/2022/06/22/Spring%E6%A1%86%E6%9E%B6IOC%E5%9F%BA%E7%A1%80/%E6%89%AB%E6%8F%8F%E5%99%A8filter%E5%8C%B9%E9%85%8D%E5%80%BC.png" class="" title="这是一张图片"><img src="C:\Users\Administrator.DESKTOP-O1Q8NN4\Pictures\Camera Roll\扫描器filter匹配值.png" alt="扫描器filter匹配值" style="zoom:75%;" /><h4 id="Bean属性注入（注解）"><a href="#Bean属性注入（注解）" class="headerlink" title="Bean属性注入（注解）"></a>Bean属性注入（注解）</h4><p>【疑问】</p><p>感觉注解作为配置文件的替代品，其实已经很底层了。也就是说我不知道，为什么配置文件已配置&lt;bean&gt;标签，就会在IOC容器中生成对应类的静态工厂类，或者单例模式时，生成其实例。原理上来说通过反射是可以实现的。但是Spring框架怎么操作反射的这些都不清楚，代码看不到</p><p>那么Java让我们看到注解的定义方法就没有意义了，因为。。。其实也能强行使用注解。就是比较好奇哪些@Data是怎么实现往类里面加Getter函数的，这个和上面“类初始化的”功能不同，是有能力参与类定义的。！！！</p><p>   这个需要扫描吗？？</p><p>1、@AutoWire:根据属性类型进行自动装配</p><p>​1）把Service和Daol类上添加@Component4注解之一</p><p>​2）在Service注入dao对象：先在Service类中定义Dao类型字段，再在字段上加注解@Autowire</p><p>​注意这里不需要添加 Setter方法</p><p>​        <strong>【疑问：运行流程】</strong></p><p>2）@Qualifier：根据属性名称进行注入</p><p>​2)…加@AutoWire 和@Qualifier（”student”)    必须一起搭配使用</p><p>3）@Resource：可以根据属性名称、也可以根据属性类型注入</p><p>​2）加@Resource按照类型注入  加@Resource（name&#x3D;”student”)按照名字注入</p><p>4）@Value：注入普通类型属性？？？ </p><p>​ 3）加@Value（value &#x3D; “abc”)private String  name;  就等价于 String name &#x3D; “abc”;</p><h4 id="Bean管理（纯注解开发）"><a href="#Bean管理（纯注解开发）" class="headerlink" title="Bean管理（纯注解开发）"></a>Bean管理（纯注解开发）</h4><p>1、创建一个配置类 @Configuration，用来替代xml配置文件‘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.example&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、编写测试类 要用支持注解的类来生命context</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line"><span class="comment">//表示加载你的配置类</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>IOC中定义注入类： 1、xml方式（给类取ID，赋<strong>路径值</strong>）</p><p>​2、@Service注解+xml (注解负责取名，xml负责路径问题，赋<strong>扫描包路径</strong>值)</p><p>​3、配置类的出现，代替xml来<strong>赋扫描包路径值</strong></p><p>​<strong>【疑问】</strong>距离现在SpringBoot逻辑断层，是<strong>配置类没有找到</strong>？</p><p>​不管是@Service定义的注入类。 还是@Controller类下注入类类型字段@Service的自动装配，前提都是需要配置扫描路径。这一步在SpringBoot当前写法中没有体现？？</p><p>至于为什么没有<strong>ApplicationContext取用注入类</strong>。我觉得这个和<strong>注入类字段自动装配</strong>的区别就是。你能不能容忍在调用类里加一个被注入类的字段，这显然是无伤大雅的。</p><p>*<strong>SpringBoot还有优化</strong>  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Js一点笔记</title>
      <link href="/2022/06/20/Js%E4%B8%80%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/20/Js%E4%B8%80%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>弱类型（先声明后定义）</p><p><strong>var</strong> ：根据var声明变量的位置确定作用域（全局、局部）</p><p>缺陷：没有考虑块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> int i = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    int i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//结果是2</span></span><br></pre></td></tr></table></figure><p>后来有了<strong>let</strong>和<strong>const</strong>用来区分变量和常量，也补全了块局部常变量。</p><p>同样，根据let、const声明变量的位置确定作用域（全局、局部）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//结果是1</span></span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">const</span> i = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//结果是1</span></span><br></pre></td></tr></table></figure><p>事件原理？</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>​由于弱类型的语法规则，JavaScript对标识符的解释也更加灵活。比如下面，value可以是各种参数类型、也可以是对象、数组、函数。</p><p>回调就是利用了此规则，传递函数标识符的过程。</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220620105840001.png" alt="image-20220620105840001"></p><h3 id="异步操作（常用回调）"><a href="#异步操作（常用回调）" class="headerlink" title="异步操作（常用回调）"></a>异步操作（常用回调）</h3><ul><li><p>执行时间较长或不可预期的函数都被封装成异步函数（如HTTP请求）</p></li><li><p>异步操作常把函数标识符（或匿名函数）作为参数</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sayounala!&quot;</span>);</span><br><span class="line">           &#125;, <span class="number">3000</span>);    <span class="comment">//超时回调</span></span><br></pre></td></tr></table></figure><h5 id="1-2-引用异步操作中的变量时的错误"><a href="#1-2-引用异步操作中的变量时的错误" class="headerlink" title="1-2. 引用异步操作中的变量时的错误"></a>1-2. 引用异步操作中的变量时的错误</h5><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220617182347369.png" alt="image-20220617182347369" style="zoom:67%;" /><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220617182916662.png" alt="image-20220617182916662" style="zoom:67%;" /><p>​结果显示下面 undefined。也就是instance.get()是异步函数，执行到此时开辟新资源，后面的代码不会被阻塞。当执行到this.fsupplierId&#x3D;receiData.data.data.fsupplierId时，异步函数并没有执行完毕，所以赋了个没有定义的值。</p><p>​所以一般会在异步函数体内把要做的事做完，如果要处理的事情过则显得逻辑不清，使用promise写法使流程更清晰。</p><h3 id="流程控制结构Promise"><a href="#流程控制结构Promise" class="headerlink" title="流程控制结构Promise"></a>流程控制结构Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolce, reject</span>)&#123;</span><br><span class="line">  dosth1...</span><br><span class="line">  <span class="title function_">resolce</span>(<span class="string">&quot;跳转到then的参数value&quot;</span>);</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;跳转到catch的参数value&quot;</span>);</span><br><span class="line">  </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;<span class="title function_">dosth2</span>(value);</span><br><span class="line">            &#125;</span><br><span class="line">  ).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">valu1</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了catch函数...&quot;</span>+valu1)</span><br><span class="line">            &#125;      </span><br><span class="line">  ).<span class="title function_">finally</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了finally函数...&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>​上面代码中，就灵活地使用了回调，Promise构造函数第一个参数是回调，回调函数的两个参数也都是回调。then、catch、finally参数都是回调</p><p>规则：</p><ul><li>then、catch不会主动执行，须在promise参数函数体中调用</li><li>finally在then或catch被调用的条件下，会被调用</li><li>catch被调用：promise参数函数体中reject(参数)或者throw “参数”<br>该catch函数之前的上一个含throw指令的函数  参数个数只能为1</li><li>then被调用：promise参数函数体中resolce(参数)会按顺序执行完所有的then函数，return传递参数  参数个数只能为1</li><li><strong>注意promise参数函数体中return代表退出，不会调用then</strong></li><li>promise参数函数体中只执行第一个resole或reject语句，后续无效</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络协议基础</title>
      <link href="/2022/06/08/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/06/08/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="网络是怎样连接的"><a href="#网络是怎样连接的" class="headerlink" title="网络是怎样连接的"></a>网络是怎样连接的</h3><h5 id="网络连接设备"><a href="#网络连接设备" class="headerlink" title="网络连接设备"></a>网络连接设备</h5><ul><li><p>局域网、城际网、广域网连接方式？结构是否与公网ip有某种关联</p></li><li><p>集线器、路由器、防火墙、交换机，在网络连接中的具体作用、位置</p></li><li><p><a href="http://www.lab.glasscom.com域名分级含义/">www.lab.glasscom.com域名分级含义</a></p></li><li><p>DNS服务器（解析过程）</p><p><img src="E:\blog\source_posts\网络协议基础\DNS解析域名过程.png" alt="DNS解析域名过程"></p></li><li><p>HTTP协议把文档图片都作为单独的对象处理，每获取一次数据对象就需访问一次服务器（如访问一张含n张图片的网页：先获取html文件，再依次获取对应的图片，总共访问1+n次）</p></li></ul><h5 id="协议栈和网卡"><a href="#协议栈和网卡" class="headerlink" title="协议栈和网卡"></a>协议栈和网卡</h5><ul><li>数据包和ip路由的出现，结束了集线器只能广播（同时只能进行一对pc的通信），1.使得路由有选择的发送给下一跳，2.减少转发每一数据包的时间，感觉上路由器在“同时”进行对不同pc的通信</li><li></li></ul><h3 id="图解TCP-x2F-IP"><a href="#图解TCP-x2F-IP" class="headerlink" title="图解TCP&#x2F;IP"></a>图解TCP&#x2F;IP</h3><h3 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础笔记</title>
      <link href="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue兼容html规则"><a href="#Vue兼容html规则" class="headerlink" title="Vue兼容html规则"></a>Vue兼容html规则</h3><p>&lt;组件名称   区域2（组件属性赋值）&gt;   区域1 &lt;&#x2F;组件名称&gt;</p><p>区域1：可输入直接展示的字串或嵌套其他组件</p><p>​Vue规则为{ {  表达式  } } </p><p>区域2：key&#x3D;”value”赋值组件属性</p><p>​value有时要求为表达式，有时则只是普通字符串</p><p>​Vue规则为   当value要求为普通对象时，且想通过表达式传递值时，可以加上v-bind：前缀,Vue解析模板时视为表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">    &lt;h1 v-bind:value=&quot;name&quot;&gt;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">    &lt;!-- 简写1 ：value=&quot;name&quot;--&gt;</span><br><span class="line">&lt;!-- 简写2: v-bind=&quot;name&quot; 默认赋给value属性--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&#x27;#root&#x27;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            name:&#x27;jack&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="数据绑定与代理"><a href="#数据绑定与代理" class="headerlink" title="数据绑定与代理"></a>数据绑定与代理</h3><h5 id="数据绑定："><a href="#数据绑定：" class="headerlink" title="数据绑定："></a>数据绑定：</h5><p>​使用 v-bind时，Vue单向检测到引用的data下的变量变化（如上例中name）时，会及时重新解析容器，重新渲染展示最新的变量值</p><p>​使用v-model时，Vue双向检测页面输入的值、data下引用的变量，使二者数值保持一致。</p><h5 id="数据绑定的原理："><a href="#数据绑定的原理：" class="headerlink" title="数据绑定的原理："></a>数据绑定的原理：</h5><p>​1.表达式可以直接访问data内变量，因为Vue代理了data对象中的字段</p><p>​2.前端页面值变——&gt;$data变量随着变</p><p>​  $data变量变——&gt;前端页面值变</p><p>​类似解析的过程和解析的反过程</p><h5 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">题外话：js给对象增加属性key</span><br><span class="line">对象名.新属性名 = 属性值</span><br><span class="line">如  Vue._proto_.aa= &#x27;gaga&#x27;;</span><br><span class="line">js删除对象属性</span><br><span class="line">delete Vue._proto_.aa;</span><br></pre></td></tr></table></figure><p>此外，还有一个api可以新增对象字段，并指定新增字段所代理的 变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor);</span><br><span class="line"><span class="comment">//obj:对象</span></span><br><span class="line"><span class="comment">//prop：新增的字段名</span></span><br><span class="line"><span class="comment">/*descriptor：配置对象&#123;</span></span><br><span class="line"><span class="comment">众多属性中有一个getter和setter</span></span><br><span class="line"><span class="comment">get：function()&#123;</span></span><br><span class="line"><span class="comment">return  被代理的对象值</span></span><br><span class="line"><span class="comment">&#125;,</span></span><br><span class="line"><span class="comment">set:function(value)&#123;</span></span><br><span class="line"><span class="comment">    被代理的对象 = value;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>get方法在prop被读取之前调用，返回值即prop被读取到的值；</p><p>set方法在prop被赋值时调用，赋值给 被代理的对象。</p><p>prop没有实际的存储内容，它代理了某个字段，感觉就是把该字段封装到了自己的逻辑内，也像引用。</p><p>可以暴露被代理的字段，但注意不能随便删除。</p><h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><p>？？？</p><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>元素标签或组件标签的响应行为</p><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>计算属性是现存属性的代理者且getter、setter可以以某种计算关系 return   f (被代理字段)</p><h4 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h4><p>监视data某属性的字面值，字面值变动时会调用handler方法；</p><p>深度监视：当监视data内对象属性内的属性变化时，也会调用handler方法；</p><p>​开启条件：监视属性的 配置对象中 deep:true</p><h4 id="列表渲染、过滤、排序"><a href="#列表渲染、过滤、排序" class="headerlink" title="列表渲染、过滤、排序"></a>列表渲染、过滤、排序</h4><h5 id="key原理："><a href="#key原理：" class="headerlink" title="key原理："></a>key原理：</h5><p>vue使用key属性管理虚拟dom的对比算法的比较依据，依据key的对应关系，将新的虚拟DOM信息补充到旧的DOM信息中，装载完成时（真实DOM）key销毁</p><p>【易错点】</p><ul><li>以数组的索引index为key，引起的对比算法出错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;(stu,index) in students&quot; :key=&quot;index&quot;&gt;</span><br><span class="line"> &#123;&#123;stu.name&#125;&#125;-&#123;&#123;stu.age&#125;&#125;</span><br><span class="line">    &lt;input type=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>假设在输入框输入对应信息</p><p>当使用数组api在数组index&#x3D;0的位置插入新数据时，Vue依据对比算法重新渲染页面，此时会出现意想不到的结果</p><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-20220606233226859.png" class="" title="这是一张图片">![image-20220606233226859](E:\blog\source\_posts\Vue基础笔记\image-20220606233226859.png)<p>因为</p><ul><li>数组下标index  插入前后对应数据是变化的，key也随之变化</li></ul><p>​0张三1李四2王五————0老刘1张三2李四3王五</p><ul><li>而右侧输入框key值始终没有变动</li></ul><p>​所以出现匹配上的差错</p><p>即用数组下标index做为key是不准确的，需要一个不因数组插入顺序而引起变动的恒定的关系值来作为key值，例如id</p><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>与原生指令比较：</p><ul><li>本质是自定义指令及指令生命周期回调函数（3个钩子）</li><li>bind   指令与元素成功绑定</li><li>inserted   元素被插入页面时</li><li>update   指令所在模板被解析时</li></ul><h4 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h4><p>四对钩子</p><ul><li>beforeCreate    （创建数据监测、数据代理前后） created</li><li>beforeMount       （挂载前后）   mounted</li><li>beforeUpdate       （更新前后）   updated</li><li>beforeDestroy        （销毁前后）  destroyed</li></ul><h4 id="ref标签属性"><a href="#ref标签属性" class="headerlink" title="ref标签属性"></a>ref标签属性</h4><p>&lt; template &gt; &lt; &#x2F;template &gt;内附加给某标签（元素标签、组件标签）上ref&#x3D;”引用名称”,</p><p>则可以通过当前Vue实例.$refs.引用名称 获取该标签的引用。</p><h5 id="上下级组件间通信（下级——-gt-上级）"><a href="#上下级组件间通信（下级——-gt-上级）" class="headerlink" title="上下级组件间通信（下级——&gt;上级）"></a>上下级组件间通信（下级——&gt;上级）</h5><h4 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h4><h5 id="上下级组件间通信（上级——-gt-下级）-props接收数据"><a href="#上下级组件间通信（上级——-gt-下级）-props接收数据" class="headerlink" title="上下级组件间通信（上级——&gt;下级）   props接收数据"></a>上下级组件间通信（上级——&gt;下级）   props接收数据</h5><ul><li>配置在下级组件VC配置项props：{key1:配置对象1,key2:配置对象2}中，上级组件可以在调用时直接传值</li></ul><h5 id="上下级组件间通信（下级——-gt-上级）-props接收函数"><a href="#上下级组件间通信（下级——-gt-上级）-props接收函数" class="headerlink" title="上下级组件间通信（下级——&gt;上级）  props接收函数"></a>上下级组件间通信（下级——&gt;上级）  props接收函数</h5><ul><li>特殊用法：上级组件可以把自己定义的函数赋值给下级，下级用props:[‘函数名’],接收且可以封装到自己的函数中。函数体内this指向声明它的组件实例（上级组件），调用所在组件的字段接收传入的参数信息。</li></ul><h4 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h4><ul><li><p>SessionStorage存储内容浏览器关闭时清除</p></li><li><p>LocalStorage浏览器不清除，需手动清除</p></li><li><p>5MB左右</p></li></ul><h4 id="全局事件总线（全局组件通信）"><a href="#全局事件总线（全局组件通信）" class="headerlink" title="全局事件总线（全局组件通信）"></a>全局事件总线（全局组件通信）</h4><ul><li>原型继承链</li></ul><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/proto.png" class="" title="这是一张图片"><p><img src="E:\blog\source_posts\Vue基础笔记\proto.png" alt="proto"></p><p>概括的说</p><ul><li><p>Vue原型类 继承了Object    VueComponent原型类 继承了Vue原型</p></li><li><p>而 new  Vue((配置项)) 是利用输入的配置信息修改和拓展了Vue原型类的定义   即Vue实例的匿名类 继承了 Vue原型类</p></li><li><p>同理 VueComponent实例的匿名类  继承了 VueComponent原型类</p></li></ul><p>vue不讲究访问权限，即继承链以上的属性和方法都可以调用</p><h5 id="关键要素1：所有组件能够共用"><a href="#关键要素1：所有组件能够共用" class="headerlink" title="关键要素1：所有组件能够共用"></a>关键要素1：所有组件能够共用</h5><p>想要Vue实例和VueComponent实例都能调用的属性，则属性必须在Vue原型类上或者Object类（排除）上才符合</p><h5 id="关键要素2：能调用如下方法"><a href="#关键要素2：能调用如下方法" class="headerlink" title="关键要素2：能调用如下方法"></a>关键要素2：能调用如下方法</h5><p>Vue的原型类上的三个方法：</p><ul><li>$on 绑定事件    .$on(‘事件名’，响应函数)</li><li>$off 卸载事件   </li><li>$emit 调用事件     .$emit(‘事件名’，参数列表)</li></ul><p>综上，可以考虑在Vue原型类上新增一个对象(所有组件能够共用)，这个对象是Vue或者VueComponent实例（能调用$on方法）</p><p>假设是 Vue原型类上新增x对象</p><h5 id="关键要素3：回调函数体this指向声明它的组件实例"><a href="#关键要素3：回调函数体this指向声明它的组件实例" class="headerlink" title="关键要素3：回调函数体this指向声明它的组件实例"></a>关键要素3：回调函数体this指向声明它的组件实例</h5><p>如下图，1、组件A中通过原型链引用x，绑定事件demo</p><p>2、组件D组件A中通过原型链引用x，调用事件demo，传参666</p><p>3、A中的回调函数利用this调用所在组件的字段接收传入的参数信息</p><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/bus.png" class="" title="这是一张图片"><p><img src="E:\blog\source_posts\Vue基础笔记\bus.png" alt="bus"></p><h4 id="消息订阅发布"><a href="#消息订阅发布" class="headerlink" title="消息订阅发布"></a>消息订阅发布</h4><p>依赖外部插件</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h5 id="ajax跨域请求的三种解决方法-…"><a href="#ajax跨域请求的三种解决方法-…" class="headerlink" title="ajax跨域请求的三种解决方法 …"></a>ajax跨域请求的三种解决方法 …</h5><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/daili1.jpg" class="" title="这是一张图片"><img src="E:\blog\source\_posts\Vue基础笔记\daili1.jpg" alt="daili1" style="zoom: 33%;" /><hr><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/daili2.jpg" class="" title="这是一张图片"><p><img src="E:\blog\source_posts\Vue基础笔记\daili2.jpg" alt="daili2"></p><h4 id="组件嵌套：插槽slot"><a href="#组件嵌套：插槽slot" class="headerlink" title="组件嵌套：插槽slot"></a>组件嵌套：插槽slot</h4><p>组件标签默认不支持嵌套的，即&lt; 组件 &gt;  &lt; 其他标签 &#x2F; &gt;  &lt; &#x2F; 组件 &gt;这种写法，中间识别不出</p><p>需要在组件的vue文件的&lt; template &gt;中 &lt; slot &#x2F;&gt;指定外部标签插入的位置</p><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL初印象</title>
      <link href="/2022/06/05/MySQL%E5%88%9D%E5%8D%B0%E8%B1%A1/"/>
      <url>/2022/06/05/MySQL%E5%88%9D%E5%8D%B0%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>查有联表和组合，</p><p>函数不过字段集合。</p><p>过滤得分行分组，</p><p>行过滤全文本还是正则？</p><p>事务擅使细致多，</p><p>游标循环是一伙。</p><p>视图也要挑大梁，</p><p>触发器存储来帮忙。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
