<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Js一点笔记</title>
      <link href="/2022/06/20/Js%E4%B8%80%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/20/Js%E4%B8%80%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>弱类型（先声明后定义）</p><p><strong>var</strong> ：根据var声明变量的位置确定作用域（全局、局部）</p><p>缺陷：没有考虑块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> int i = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    int i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//结果是2</span></span><br></pre></td></tr></table></figure><p>后来有了<strong>let</strong>和<strong>const</strong>用来区分变量和常量，也补全了块局部常变量。</p><p>同样，根据let、const声明变量的位置确定作用域（全局、局部）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//结果是1</span></span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">const</span> i = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> i = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//结果是1</span></span><br></pre></td></tr></table></figure><p>事件原理？</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>​由于弱类型的语法规则，JavaScript对标识符的解释也更加灵活。比如下面，value可以是各种参数类型、也可以是对象、数组、函数。</p><p>回调就是利用了此规则，传递函数标识符的过程。</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220620105840001.png" alt="image-20220620105840001"></p><h3 id="异步操作（常用回调）"><a href="#异步操作（常用回调）" class="headerlink" title="异步操作（常用回调）"></a>异步操作（常用回调）</h3><ul><li><p>执行时间较长或不可预期的函数都被封装成异步函数（如HTTP请求）</p></li><li><p>异步操作常把函数标识符（或匿名函数）作为参数</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sayounala!&quot;</span>);</span><br><span class="line">           &#125;, <span class="number">3000</span>);    <span class="comment">//超时回调</span></span><br></pre></td></tr></table></figure><h5 id="1-2-引用异步操作中的变量时的错误"><a href="#1-2-引用异步操作中的变量时的错误" class="headerlink" title="1-2. 引用异步操作中的变量时的错误"></a>1-2. 引用异步操作中的变量时的错误</h5><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220617182347369.png" alt="image-20220617182347369" style="zoom:67%;" /><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220617182916662.png" alt="image-20220617182916662" style="zoom:67%;" /><p>​结果显示下面 undefined。也就是instance.get()是异步函数，执行到此时开辟新资源，后面的代码不会被阻塞。当执行到this.fsupplierId&#x3D;receiData.data.data.fsupplierId时，异步函数并没有执行完毕，所以赋了个没有定义的值。</p><p>​所以一般会在异步函数体内把要做的事做完，如果要处理的事情过则显得逻辑不清，使用promise写法使流程更清晰。</p><h3 id="流程控制结构Promise"><a href="#流程控制结构Promise" class="headerlink" title="流程控制结构Promise"></a>流程控制结构Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolce, reject</span>)&#123;</span><br><span class="line">  dosth1...</span><br><span class="line">  <span class="title function_">resolce</span>(<span class="string">&quot;跳转到then的参数value&quot;</span>);</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;跳转到catch的参数value&quot;</span>);</span><br><span class="line">  </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;<span class="title function_">dosth2</span>(value);</span><br><span class="line">            &#125;</span><br><span class="line">  ).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">valu1</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了catch函数...&quot;</span>+valu1)</span><br><span class="line">            &#125;      </span><br><span class="line">  ).<span class="title function_">finally</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了finally函数...&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>​上面代码中，就灵活地使用了回调，Promise构造函数第一个参数是回调，回调函数的两个参数也都是回调。then、catch、finally参数都是回调</p><p>规则：</p><ul><li>then、catch不会主动执行，须在promise参数函数体中调用</li><li>finally在then或catch被调用的条件下，会被调用</li><li>catch被调用：promise参数函数体中reject(参数)或者throw “参数”<br>该catch函数之前的上一个含throw指令的函数  参数个数只能为1</li><li>then被调用：promise参数函数体中resolce(参数)会按顺序执行完所有的then函数，return传递参数  参数个数只能为1</li><li><strong>注意promise参数函数体中return代表退出，不会调用then</strong></li><li>promise参数函数体中只执行第一个resole或reject语句，后续无效</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络协议基础</title>
      <link href="/2022/06/08/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/06/08/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="网络是怎样连接的"><a href="#网络是怎样连接的" class="headerlink" title="网络是怎样连接的"></a>网络是怎样连接的</h3><h5 id="网络连接设备"><a href="#网络连接设备" class="headerlink" title="网络连接设备"></a>网络连接设备</h5><ul><li><p>局域网、城际网、广域网连接方式？结构是否与公网ip有某种关联</p></li><li><p>集线器、路由器、防火墙、交换机，在网络连接中的具体作用、位置</p></li><li><p><a href="http://www.lab.glasscom.com域名分级含义/">www.lab.glasscom.com域名分级含义</a></p></li><li><p>DNS服务器（解析过程）</p><p><img src="E:\blog\source_posts\网络协议基础\DNS解析域名过程.png" alt="DNS解析域名过程"></p></li><li><p>HTTP协议把文档图片都作为单独的对象处理，每获取一次数据对象就需访问一次服务器（如访问一张含n张图片的网页：先获取html文件，再依次获取对应的图片，总共访问1+n次）</p></li></ul><h5 id="协议栈和网卡"><a href="#协议栈和网卡" class="headerlink" title="协议栈和网卡"></a>协议栈和网卡</h5><ul><li>数据包和ip路由的出现，结束了集线器只能广播（同时只能进行一对pc的通信），1.使得路由有选择的发送给下一跳，2.减少转发每一数据包的时间，感觉上路由器在“同时”进行对不同pc的通信</li><li></li></ul><h3 id="图解TCP-x2F-IP"><a href="#图解TCP-x2F-IP" class="headerlink" title="图解TCP&#x2F;IP"></a>图解TCP&#x2F;IP</h3><h3 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础笔记</title>
      <link href="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue兼容html规则"><a href="#Vue兼容html规则" class="headerlink" title="Vue兼容html规则"></a>Vue兼容html规则</h3><p>&lt;组件名称   区域2（组件属性赋值）&gt;   区域1 &lt;&#x2F;组件名称&gt;</p><p>区域1：可输入直接展示的字串或嵌套其他组件</p><p>​Vue规则为{ {  表达式  } } </p><p>区域2：key&#x3D;”value”赋值组件属性</p><p>​value有时要求为表达式，有时则只是普通字符串</p><p>​Vue规则为   当value要求为普通对象时，且想通过表达式传递值时，可以加上v-bind：前缀,Vue解析模板时视为表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">    &lt;h1 v-bind:value=&quot;name&quot;&gt;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">    &lt;!-- 简写1 ：value=&quot;name&quot;--&gt;</span><br><span class="line">&lt;!-- 简写2: v-bind=&quot;name&quot; 默认赋给value属性--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&#x27;#root&#x27;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            name:&#x27;jack&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="数据绑定与代理"><a href="#数据绑定与代理" class="headerlink" title="数据绑定与代理"></a>数据绑定与代理</h3><h5 id="数据绑定："><a href="#数据绑定：" class="headerlink" title="数据绑定："></a>数据绑定：</h5><p>​使用 v-bind时，Vue单向检测到引用的data下的变量变化（如上例中name）时，会及时重新解析容器，重新渲染展示最新的变量值</p><p>​使用v-model时，Vue双向检测页面输入的值、data下引用的变量，使二者数值保持一致。</p><h5 id="数据绑定的原理："><a href="#数据绑定的原理：" class="headerlink" title="数据绑定的原理："></a>数据绑定的原理：</h5><p>​1.表达式可以直接访问data内变量，因为Vue代理了data对象中的字段</p><p>​2.前端页面值变——&gt;$data变量随着变</p><p>​  $data变量变——&gt;前端页面值变</p><p>​类似解析的过程和解析的反过程</p><h5 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">题外话：js给对象增加属性key</span><br><span class="line">对象名.新属性名 = 属性值</span><br><span class="line">如  Vue._proto_.aa= &#x27;gaga&#x27;;</span><br><span class="line">js删除对象属性</span><br><span class="line">delete Vue._proto_.aa;</span><br></pre></td></tr></table></figure><p>此外，还有一个api可以新增对象字段，并指定新增字段所代理的 变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor);</span><br><span class="line"><span class="comment">//obj:对象</span></span><br><span class="line"><span class="comment">//prop：新增的字段名</span></span><br><span class="line"><span class="comment">/*descriptor：配置对象&#123;</span></span><br><span class="line"><span class="comment">众多属性中有一个getter和setter</span></span><br><span class="line"><span class="comment">get：function()&#123;</span></span><br><span class="line"><span class="comment">return  被代理的对象值</span></span><br><span class="line"><span class="comment">&#125;,</span></span><br><span class="line"><span class="comment">set:function(value)&#123;</span></span><br><span class="line"><span class="comment">    被代理的对象 = value;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>get方法在prop被读取之前调用，返回值即prop被读取到的值；</p><p>set方法在prop被赋值时调用，赋值给 被代理的对象。</p><p>prop没有实际的存储内容，它代理了某个字段，感觉就是把该字段封装到了自己的逻辑内，也像引用。</p><p>可以暴露被代理的字段，但注意不能随便删除。</p><h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><p>？？？</p><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>元素标签或组件标签的响应行为</p><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>计算属性是现存属性的代理者且getter、setter可以以某种计算关系 return   f (被代理字段)</p><h4 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h4><p>监视data某属性的字面值，字面值变动时会调用handler方法；</p><p>深度监视：当监视data内对象属性内的属性变化时，也会调用handler方法；</p><p>​开启条件：监视属性的 配置对象中 deep:true</p><h4 id="列表渲染、过滤、排序"><a href="#列表渲染、过滤、排序" class="headerlink" title="列表渲染、过滤、排序"></a>列表渲染、过滤、排序</h4><h5 id="key原理："><a href="#key原理：" class="headerlink" title="key原理："></a>key原理：</h5><p>vue使用key属性管理虚拟dom的对比算法的比较依据，依据key的对应关系，将新的虚拟DOM信息补充到旧的DOM信息中，装载完成时（真实DOM）key销毁</p><p>【易错点】</p><ul><li>以数组的索引index为key，引起的对比算法出错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;(stu,index) in students&quot; :key=&quot;index&quot;&gt;</span><br><span class="line"> &#123;&#123;stu.name&#125;&#125;-&#123;&#123;stu.age&#125;&#125;</span><br><span class="line">    &lt;input type=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>假设在输入框输入对应信息</p><p>当使用数组api在数组index&#x3D;0的位置插入新数据时，Vue依据对比算法重新渲染页面，此时会出现意想不到的结果</p><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-20220606233226859.png" class="" title="这是一张图片">![image-20220606233226859](E:\blog\source\_posts\Vue基础笔记\image-20220606233226859.png)<p>因为</p><ul><li>数组下标index  插入前后对应数据是变化的，key也随之变化</li></ul><p>​0张三1李四2王五————0老刘1张三2李四3王五</p><ul><li>而右侧输入框key值始终没有变动</li></ul><p>​所以出现匹配上的差错</p><p>即用数组下标index做为key是不准确的，需要一个不因数组插入顺序而引起变动的恒定的关系值来作为key值，例如id</p><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>与原生指令比较：</p><ul><li>本质是自定义指令及指令生命周期回调函数（3个钩子）</li><li>bind   指令与元素成功绑定</li><li>inserted   元素被插入页面时</li><li>update   指令所在模板被解析时</li></ul><h4 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h4><p>四对钩子</p><ul><li>beforeCreate    （创建数据监测、数据代理前后） created</li><li>beforeMount       （挂载前后）   mounted</li><li>beforeUpdate       （更新前后）   updated</li><li>beforeDestroy        （销毁前后）  destroyed</li></ul><h4 id="ref标签属性"><a href="#ref标签属性" class="headerlink" title="ref标签属性"></a>ref标签属性</h4><p>&lt; template &gt; &lt; &#x2F;template &gt;内附加给某标签（元素标签、组件标签）上ref&#x3D;”引用名称”,</p><p>则可以通过当前Vue实例.$refs.引用名称 获取该标签的引用。</p><h5 id="上下级组件间通信（下级——-gt-上级）"><a href="#上下级组件间通信（下级——-gt-上级）" class="headerlink" title="上下级组件间通信（下级——&gt;上级）"></a>上下级组件间通信（下级——&gt;上级）</h5><h4 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h4><h5 id="上下级组件间通信（上级——-gt-下级）-props接收数据"><a href="#上下级组件间通信（上级——-gt-下级）-props接收数据" class="headerlink" title="上下级组件间通信（上级——&gt;下级）   props接收数据"></a>上下级组件间通信（上级——&gt;下级）   props接收数据</h5><ul><li>配置在下级组件VC配置项props：{key1:配置对象1,key2:配置对象2}中，上级组件可以在调用时直接传值</li></ul><h5 id="上下级组件间通信（下级——-gt-上级）-props接收函数"><a href="#上下级组件间通信（下级——-gt-上级）-props接收函数" class="headerlink" title="上下级组件间通信（下级——&gt;上级）  props接收函数"></a>上下级组件间通信（下级——&gt;上级）  props接收函数</h5><ul><li>特殊用法：上级组件可以把自己定义的函数赋值给下级，下级用props:[‘函数名’],接收且可以封装到自己的函数中。函数体内this指向声明它的组件实例（上级组件），调用所在组件的字段接收传入的参数信息。</li></ul><h4 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h4><ul><li><p>SessionStorage存储内容浏览器关闭时清除</p></li><li><p>LocalStorage浏览器不清除，需手动清除</p></li><li><p>5MB左右</p></li></ul><h4 id="全局事件总线（全局组件通信）"><a href="#全局事件总线（全局组件通信）" class="headerlink" title="全局事件总线（全局组件通信）"></a>全局事件总线（全局组件通信）</h4><ul><li>原型继承链</li></ul><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/proto.png" class="" title="这是一张图片"><p><img src="E:\blog\source_posts\Vue基础笔记\proto.png" alt="proto"></p><p>概括的说</p><ul><li><p>Vue原型类 继承了Object    VueComponent原型类 继承了Vue原型</p></li><li><p>而 new  Vue((配置项)) 是利用输入的配置信息修改和拓展了Vue原型类的定义   即Vue实例的匿名类 继承了 Vue原型类</p></li><li><p>同理 VueComponent实例的匿名类  继承了 VueComponent原型类</p></li></ul><p>vue不讲究访问权限，即继承链以上的属性和方法都可以调用</p><h5 id="关键要素1：所有组件能够共用"><a href="#关键要素1：所有组件能够共用" class="headerlink" title="关键要素1：所有组件能够共用"></a>关键要素1：所有组件能够共用</h5><p>想要Vue实例和VueComponent实例都能调用的属性，则属性必须在Vue原型类上或者Object类（排除）上才符合</p><h5 id="关键要素2：能调用如下方法"><a href="#关键要素2：能调用如下方法" class="headerlink" title="关键要素2：能调用如下方法"></a>关键要素2：能调用如下方法</h5><p>Vue的原型类上的三个方法：</p><ul><li>$on 绑定事件    .$on(‘事件名’，响应函数)</li><li>$off 卸载事件   </li><li>$emit 调用事件     .$emit(‘事件名’，参数列表)</li></ul><p>综上，可以考虑在Vue原型类上新增一个对象(所有组件能够共用)，这个对象是Vue或者VueComponent实例（能调用$on方法）</p><p>假设是 Vue原型类上新增x对象</p><h5 id="关键要素3：回调函数体this指向声明它的组件实例"><a href="#关键要素3：回调函数体this指向声明它的组件实例" class="headerlink" title="关键要素3：回调函数体this指向声明它的组件实例"></a>关键要素3：回调函数体this指向声明它的组件实例</h5><p>如下图，1、组件A中通过原型链引用x，绑定事件demo</p><p>2、组件D组件A中通过原型链引用x，调用事件demo，传参666</p><p>3、A中的回调函数利用this调用所在组件的字段接收传入的参数信息</p><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/bus.png" class="" title="这是一张图片"><p><img src="E:\blog\source_posts\Vue基础笔记\bus.png" alt="bus"></p><h4 id="消息订阅发布"><a href="#消息订阅发布" class="headerlink" title="消息订阅发布"></a>消息订阅发布</h4><p>依赖外部插件</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h5 id="ajax跨域请求的三种解决方法-…"><a href="#ajax跨域请求的三种解决方法-…" class="headerlink" title="ajax跨域请求的三种解决方法 …"></a>ajax跨域请求的三种解决方法 …</h5><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/daili1.jpg" class="" title="这是一张图片"><img src="E:\blog\source\_posts\Vue基础笔记\daili1.jpg" alt="daili1" style="zoom: 33%;" /><hr><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/daili2.jpg" class="" title="这是一张图片"><p><img src="E:\blog\source_posts\Vue基础笔记\daili2.jpg" alt="daili2"></p><h4 id="组件嵌套：插槽slot"><a href="#组件嵌套：插槽slot" class="headerlink" title="组件嵌套：插槽slot"></a>组件嵌套：插槽slot</h4><p>组件标签默认不支持嵌套的，即&lt; 组件 &gt;  &lt; 其他标签 &#x2F; &gt;  &lt; &#x2F; 组件 &gt;这种写法，中间识别不出</p><p>需要在组件的vue文件的&lt; template &gt;中 &lt; slot &#x2F;&gt;指定外部标签插入的位置</p><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL初印象</title>
      <link href="/2022/06/05/MySQL%E5%88%9D%E5%8D%B0%E8%B1%A1/"/>
      <url>/2022/06/05/MySQL%E5%88%9D%E5%8D%B0%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>查有联表和组合，</p><p>函数不过字段集合。</p><p>过滤得分行分组，</p><p>行过滤全文本还是正则？</p><p>事务擅使细致多，</p><p>游标循环是一伙。</p><p>视图也要挑大梁，</p><p>触发器存储来帮忙。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
