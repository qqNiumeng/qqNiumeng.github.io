<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络协议基础</title>
      <link href="/2022/06/08/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/06/08/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="网络是怎样连接的"><a href="#网络是怎样连接的" class="headerlink" title="网络是怎样连接的"></a>网络是怎样连接的</h3><h3 id="图解TCP-x2F-IP"><a href="#图解TCP-x2F-IP" class="headerlink" title="图解TCP&#x2F;IP"></a>图解TCP&#x2F;IP</h3><h3 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础笔记</title>
      <link href="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue兼容html规则"><a href="#Vue兼容html规则" class="headerlink" title="Vue兼容html规则"></a>Vue兼容html规则</h3><p>&lt;组件名称   区域2（组件属性赋值）&gt;   区域1 &lt;&#x2F;组件名称&gt;</p><p>区域1：可输入直接展示的字串或嵌套其他组件</p><p>​Vue规则为{ {  表达式  } } </p><p>区域2：key&#x3D;”value”赋值组件属性</p><p>​value有时要求为表达式，有时则只是普通字符串</p><p>​Vue规则为   当value要求为普通对象时，且想通过表达式传递值时，可以加上v-bind：前缀,Vue解析模板时视为表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">    &lt;h1 v-bind:value=&quot;name&quot;&gt;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">    &lt;!-- 简写1 ：value=&quot;name&quot;--&gt;</span><br><span class="line">&lt;!-- 简写2: v-bind=&quot;name&quot; 默认赋给value属性--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&#x27;#root&#x27;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            name:&#x27;jack&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="数据绑定与代理"><a href="#数据绑定与代理" class="headerlink" title="数据绑定与代理"></a>数据绑定与代理</h3><h5 id="数据绑定："><a href="#数据绑定：" class="headerlink" title="数据绑定："></a>数据绑定：</h5><p>​使用 v-bind时，Vue单向检测到引用的data下的变量变化（如上例中name）时，会及时重新解析容器，重新渲染展示最新的变量值</p><p>​使用v-model时，Vue双向检测页面输入的值、data下引用的变量，使二者数值保持一致。</p><h5 id="数据绑定的原理："><a href="#数据绑定的原理：" class="headerlink" title="数据绑定的原理："></a>数据绑定的原理：</h5><p>​1.表达式可以直接访问data内变量，因为Vue代理了data对象中的字段</p><p>​2.前端页面值变——&gt;$data变量随着变</p><p>​  $data变量变——&gt;前端页面值变</p><p>​类似解析的过程和解析的反过程</p><h5 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">题外话：js给对象增加属性key</span><br><span class="line">对象名.新属性名 = 属性值</span><br><span class="line">如  Vue._proto_.aa= &#x27;gaga&#x27;;</span><br><span class="line">js删除对象属性</span><br><span class="line">delete Vue._proto_.aa;</span><br></pre></td></tr></table></figure><p>此外，还有一个api可以新增对象字段，并指定新增字段所代理的 变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor);</span><br><span class="line"><span class="comment">//obj:对象</span></span><br><span class="line"><span class="comment">//prop：新增的字段名</span></span><br><span class="line"><span class="comment">/*descriptor：配置对象&#123;</span></span><br><span class="line"><span class="comment">众多属性中有一个getter和setter</span></span><br><span class="line"><span class="comment">get：function()&#123;</span></span><br><span class="line"><span class="comment">return  被代理的对象值</span></span><br><span class="line"><span class="comment">&#125;,</span></span><br><span class="line"><span class="comment">set:function(value)&#123;</span></span><br><span class="line"><span class="comment">    被代理的对象 = value;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>get方法在prop被读取之前调用，返回值即prop被读取到的值；</p><p>set方法在prop被赋值时调用，赋值给 被代理的对象。</p><p>prop没有实际的存储内容，它代理了某个字段，感觉就是把该字段封装到了自己的逻辑内，也像引用。</p><p>可以暴露被代理的字段，但注意不能随便删除。</p><h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><p>？？？</p><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>元素标签或组件标签的响应行为</p><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>计算属性是现存属性的代理者且getter、setter可以以某种计算关系 return   f (被代理字段)</p><h4 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h4><p>监视data某属性的字面值，字面值变动时会调用handler方法；</p><p>深度监视：当监视data内对象属性内的属性变化时，也会调用handler方法；</p><p>​开启条件：监视属性的 配置对象中 deep:true</p><h4 id="列表渲染、过滤、排序"><a href="#列表渲染、过滤、排序" class="headerlink" title="列表渲染、过滤、排序"></a>列表渲染、过滤、排序</h4><h5 id="key原理："><a href="#key原理：" class="headerlink" title="key原理："></a>key原理：</h5><p>vue使用key属性管理虚拟dom的对比算法的比较依据，依据key的对应关系，将新的虚拟DOM信息补充到旧的DOM信息中，装载完成时（真实DOM）key销毁</p><p>【易错点】</p><ul><li>以数组的索引index为key，引起的对比算法出错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;(stu,index) in students&quot; :key=&quot;index&quot;&gt;</span><br><span class="line"> &#123;&#123;stu.name&#125;&#125;-&#123;&#123;stu.age&#125;&#125;</span><br><span class="line">    &lt;input type=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>假设在输入框输入对应信息</p><p>当使用数组api在数组index&#x3D;0的位置插入新数据时，Vue依据对比算法重新渲染页面，此时会出现意想不到的结果</p><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-20220606233226859.png" class="" title="这是一张图片">![image-20220606233226859](E:\blog\source\_posts\Vue基础笔记\image-20220606233226859.png)<p>因为</p><ul><li>数组下标index  插入前后对应数据是变化的，key也随之变化</li></ul><p>​0张三1李四2王五————0老刘1张三2李四3王五</p><ul><li>而右侧输入框key值始终没有变动</li></ul><p>​所以出现匹配上的差错</p><p>即用数组下标index做为key是不准确的，需要一个不因数组插入顺序而引起变动的恒定的关系值来作为key值，类似记录的主键</p><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>与原生指令比较：</p><ul><li>本质是自定义指令及指令生命周期回调函数（3个钩子）</li><li>bind   指令与元素成功绑定</li><li>inserted   元素被插入页面时</li><li>update   指令所在模板被解析时</li></ul><h4 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h4><p>四对钩子</p><ul><li>beforeCreate    （创建数据监测、数据代理前后） created</li><li>beforeMount       （挂载前后）   mounted</li><li>beforeUpdate       （更新前后）   updated</li><li>beforeDestroy        （销毁前后）  destroyed</li></ul><h4 id="组件及组件嵌套"><a href="#组件及组件嵌套" class="headerlink" title="组件及组件嵌套"></a>组件及组件嵌套</h4><h4 id="ref标签属性"><a href="#ref标签属性" class="headerlink" title="ref标签属性"></a>ref标签属性</h4><p>&lt; template &gt; &lt; &#x2F;template &gt;内附加给某标签（元素标签、组件标签）上ref&#x3D;”引用名称”,</p><p>则可以通过当前Vue实例.$refs.引用名称 获取该标签的引用。</p><h5 id="上下级组件间通信（下级——-gt-上级）"><a href="#上下级组件间通信（下级——-gt-上级）" class="headerlink" title="上下级组件间通信（下级——&gt;上级）"></a>上下级组件间通信（下级——&gt;上级）</h5><h4 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h4><ul><li>配置在下级组件VC配置项props：{key1:配置对象1,key2:配置对象2}中，上级组件可以在调用时直接传值</li></ul><p>&lt; Student  key1&#x3D;”…”  &#x2F; &gt;</p><h5 id="上下级组件间通信（上级——-gt-下级）-props接收数据"><a href="#上下级组件间通信（上级——-gt-下级）-props接收数据" class="headerlink" title="上下级组件间通信（上级——&gt;下级）   props接收数据"></a>上下级组件间通信（上级——&gt;下级）   props接收数据</h5><ul><li>特殊用法：上级组件可以把自己定义的函数赋值给下级，下级用props:[‘函数名’],接收且可以封装到自己的函数中。函数体内this指向声明它的组件实例</li></ul><h5 id="上下级组件间通信（下级——-gt-上级）-props接收函数"><a href="#上下级组件间通信（下级——-gt-上级）-props接收函数" class="headerlink" title="上下级组件间通信（下级——&gt;上级）  props接收函数"></a>上下级组件间通信（下级——&gt;上级）  props接收函数</h5><h4 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h4><ul><li><p>SessionStorage存储内容浏览器关闭时清除</p></li><li><p>LocalStorage浏览器不清除，需手动清除</p></li><li><p>5MB左右</p></li></ul><h4 id="全局事件总线（全局组件通信）"><a href="#全局事件总线（全局组件通信）" class="headerlink" title="全局事件总线（全局组件通信）"></a>全局事件总线（全局组件通信）</h4><ul><li>原型继承链</li></ul><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/proto.png" class="" title="这是一张图片"><p><img src="E:\blog\source_posts\Vue基础笔记\proto.png" alt="proto"></p><p>概括的说</p><ul><li><p>Vue原型类 继承了Object    VueComponent原型类 继承了Vue原型</p></li><li><p>而 new  Vue((配置项)) 是利用输入的配置信息修改和拓展了Vue原型类的定义   即Vue实例的匿名类 继承了 Vue原型类</p></li><li><p>同理 VueComponent实例的匿名类  继承了 VueComponent原型类</p></li></ul><p>vue不讲究访问权限，即继承链以上的属性和方法都可以调用</p><h5 id="关键要素1：所有组件能够共用"><a href="#关键要素1：所有组件能够共用" class="headerlink" title="关键要素1：所有组件能够共用"></a>关键要素1：所有组件能够共用</h5><p>想要Vue实例和VueComponent实例都能调用的属性，则属性必须在Vue原型类上或者Object类（排除）上才符合</p><h5 id="关键要素2：能调用如下方法"><a href="#关键要素2：能调用如下方法" class="headerlink" title="关键要素2：能调用如下方法"></a>关键要素2：能调用如下方法</h5><p>Vue的原型类上的三个方法：</p><ul><li>$on 绑定事件    .$on(‘事件名’，响应函数)</li><li>$off 卸载事件   </li><li>$emit 调用事件     .$emit(‘事件名’，参数列表)</li></ul><p>综上，可以考虑在Vue原型类上新增一个对象(所有组件能够共用)，这个对象是Vue或者VueComponent实例（能调用$on方法）</p><p>假设是 Vue原型类上新增x对象</p><h5 id="关键要素3：回调函数体this指向声明它的组件实例"><a href="#关键要素3：回调函数体this指向声明它的组件实例" class="headerlink" title="关键要素3：回调函数体this指向声明它的组件实例"></a>关键要素3：回调函数体this指向声明它的组件实例</h5><p>如下图，1、组件A中通过原型链引用x，绑定事件a</p><p>2、组件D组件A中通过原型链引用x，调用事件a，传参666</p><p>3、A中的回调函数利用this接收传入的参数信息</p><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/bus.png" class="" title="这是一张图片"><p><img src="E:\blog\source_posts\Vue基础笔记\bus.png" alt="bus"></p><h4 id="消息订阅发布"><a href="#消息订阅发布" class="headerlink" title="消息订阅发布"></a>消息订阅发布</h4><p>依赖外部插件</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h5 id="ajax跨域请求的三种解决方法-…"><a href="#ajax跨域请求的三种解决方法-…" class="headerlink" title="ajax跨域请求的三种解决方法 …"></a>ajax跨域请求的三种解决方法 …</h5><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/daili1.jpg" class="" title="这是一张图片"><img src="E:\blog\source\_posts\Vue基础笔记\daili1.jpg" alt="daili1" style="zoom: 33%;" /><hr><img src="/2022/06/07/Vue%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/daili2.jpg" class="" title="这是一张图片"><p><img src="E:\blog\source_posts\Vue基础笔记\daili2.jpg" alt="daili2"></p><h4 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h4><p>组件标签默认不支持嵌套的，即&lt; 组件 &gt;  &lt; 其他标签 &#x2F; &gt;  &lt; &#x2F; 组件 &gt;这种写法，中间识别不出</p><p>需要在组件的vue文件的&lt; template &gt;中 &lt; slot &#x2F;&gt;指定外部标签插入的位置</p><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL初印象</title>
      <link href="/2022/06/05/MySQL%E5%88%9D%E5%8D%B0%E8%B1%A1/"/>
      <url>/2022/06/05/MySQL%E5%88%9D%E5%8D%B0%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>查有联表和组合，</p><p>函数不过字段集合。</p><p>过滤得分行分组，</p><p>行过滤全文本还是正则？</p><p>事务擅使细致多，</p><p>游标循环是一伙。</p><p>视图也要挑大梁，</p><p>触发器存储来帮忙。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
